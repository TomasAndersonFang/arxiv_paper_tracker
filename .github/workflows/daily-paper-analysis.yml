name: Daily Paper Analysis
on:
  schedule:
    - cron: '0 0 * * *'  # 每天 UTC 时间 00:00 运行
  workflow_dispatch:  # 允许手动触发

jobs:
  analyze-papers:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        # 完全禁用缓存
    
    - name: 🔍 Deep diagnosis of requirements files
      run: |
        echo "=== 🔍 COMPREHENSIVE FILE SEARCH ==="
        echo "Current working directory: $(pwd)"
        echo "All requirements-related files:"
        find . -name "*requirements*" -o -name "*require*" -o -name "*.txt" | head -20
        echo ""
        
        echo "=== 📁 Directory structure ==="
        ls -la
        echo ""
        
        echo "=== 🔍 ALL requirements*.txt files ==="
        find . -name "requirements*.txt" -type f -exec echo "📄 Found: {}" \; -exec echo "  Full path: $(realpath {})" \; -exec echo "  Content:" \; -exec cat {} \; -exec echo "  Hash: $(md5sum {})" \; -exec echo "" \;
        
        echo "=== 📄 Current directory requirements.txt ==="
        if [ -f "./requirements.txt" ]; then
          echo "✅ ./requirements.txt exists"
          echo "Full path: $(realpath ./requirements.txt)"
          echo "Size: $(wc -l < ./requirements.txt) lines, $(wc -c < ./requirements.txt) bytes"
          echo "Permissions: $(ls -la ./requirements.txt)"
          echo "Content (with line numbers):"
          cat -n ./requirements.txt
          echo "MD5: $(md5sum ./requirements.txt)"
          echo "SHA256: $(sha256sum ./requirements.txt)"
        else
          echo "❌ ./requirements.txt NOT FOUND!"
        fi
        echo ""
        
        echo "=== 🔍 Search for ANY file containing package versions ==="
        echo "Files containing 'arxiv':"
        grep -r "arxiv" . --include="*.txt" --include="*.cfg" --include="*.ini" --include="*.toml" --include="*.yml" --include="*.yaml" 2>/dev/null || echo "No files found"
        echo ""
        
        echo "=== 🌿 Git status and recent changes ==="
        git status
        echo ""
        git log --oneline -5
        echo ""
        
        echo "=== 🔍 Check if requirements.txt is tracked by git ==="
        git ls-files | grep requirements || echo "No requirements files tracked by git"
    
    - name: 🛠️ Force create correct requirements.txt
      run: |
        echo "=== 🛠️ Creating the CORRECT requirements.txt file ==="
        
        # 备份现有的requirements.txt（如果存在）
        if [ -f "./requirements.txt" ]; then
          echo "📄 Backing up existing requirements.txt"
          cp ./requirements.txt ./requirements.txt.backup.$(date +%s)
          echo "Current content of existing file:"
          cat ./requirements.txt
        fi
        
        # 强制创建正确的requirements.txt文件
        cat > ./requirements.txt << 'EOF'
arxiv==2.2.0
openai==0.28.0
requests==2.32.4
python-dotenv==1.0.0
jinja2==3.1.2
EOF
        
        echo "✅ Created new requirements.txt with correct versions:"
        cat ./requirements.txt
        echo ""
        echo "File info:"
        ls -la ./requirements.txt
        echo "MD5: $(md5sum ./requirements.txt)"
        
        # 验证文件可读性
        echo "=== 🔍 Verify file readability ==="
        python -c "
with open('requirements.txt', 'r') as f:
    content = f.read()
    print('Python can read the file:')
    print(repr(content))
    lines = content.strip().split('\n')
    print(f'Found {len(lines)} lines')
    for i, line in enumerate(lines, 1):
        print(f'Line {i}: {repr(line)}')
"
    
    - name: 🧹 Complete cache elimination and fresh installation
      run: |
        echo "=== 🧹 Completely eliminating all caches ==="
        
        # 删除所有可能的pip缓存位置
        python -m pip cache purge
        rm -rf ~/.cache/pip* ~/.pip /tmp/pip* 2>/dev/null || true
        sudo rm -rf /root/.cache/pip* 2>/dev/null || true
        
        # 删除GitHub Actions特有的缓存
        rm -rf /opt/hostedtoolcache/Python/*/x64/lib/python*/site-packages/pip/_internal/cache 2>/dev/null || true
        rm -rf /opt/hostedtoolcache/pip_cache 2>/dev/null || true
        
        # 清除可能影响缓存的环境变量
        unset PIP_CACHE_DIR PIP_FIND_LINKS PIP_EXTRA_INDEX_URL
        export PIP_NO_CACHE_DIR=1
        export PIP_DISABLE_PIP_VERSION_CHECK=1
        
        echo "=== ⬆️ Upgrading pip without cache ==="
        python -m pip install --upgrade pip --no-cache-dir --force-reinstall
        
        echo "=== 🗑️ Uninstalling existing packages ==="
        pip freeze | grep -v "^pip==" | grep -v "^setuptools==" | grep -v "^wheel==" > current_packages.txt || true
        if [ -s current_packages.txt ]; then
          echo "Uninstalling:"
          cat current_packages.txt
          pip uninstall -y -r current_packages.txt || true
        fi
        
        echo "=== ✅ Verification: packages after cleanup ==="
        pip list --format=freeze
        
        echo "=== 🧪 Test pip's requirements parsing ==="
        pip install --dry-run --no-cache-dir -r "$REQUIREMENTS_FILE" || echo "Dry run completed"
        
        echo "=== 🚀 Installing with EXPLICIT file verification ==="
        
        # 显示将要使用的文件
        echo "📄 About to install from:"
        echo "File: $(realpath requirements.txt)"
        echo "Content:"
        cat requirements.txt
        echo ""
        
        # 使用绝对路径确保使用正确的文件
        REQUIREMENTS_FILE="$(realpath requirements.txt)"
        echo "🎯 Using absolute path: $REQUIREMENTS_FILE"
        
        # 验证pip会读取什么内容
        echo "=== 🔍 Pre-install verification ==="
        python -c "
import subprocess
import sys

# 模拟pip读取requirements文件的过程
print('Testing what pip will read:')
with open('$REQUIREMENTS_FILE', 'r') as f:
    lines = f.readlines()
    for i, line in enumerate(lines, 1):
        line = line.strip()
        if line and not line.startswith('#'):
            print(f'  Line {i}: {line}')
"
        
        # 使用绝对路径安装，并实时显示输出
        pip install --no-cache-dir \
                   --force-reinstall \
                   --no-deps \
                   --index-url https://pypi.org/simple/ \
                   --disable-pip-version-check \
                   --verbose \
                   -r "$REQUIREMENTS_FILE"
        
        echo "=== 🔄 Installing dependencies ==="
        pip install --no-cache-dir \
                   --force-reinstall \
                   --index-url https://pypi.org/simple/ \
                   --disable-pip-version-check \
                   --verbose \
                   -r "$REQUIREMENTS_FILE"
        
        echo "=== 📦 Final package verification ==="
        pip list --format=freeze
    
    - name: 🎯 Hardcoded version installation (fallback)
      if: failure()
      run: |
        echo "=== 🎯 Using hardcoded versions as fallback ==="
        
        # 使用您期望的确切版本
        pip install --no-cache-dir --force-reinstall \
          "arxiv==2.2.0" \
          "openai==0.28.0" \
          "requests==2.32.4" \
          "python-dotenv==1.0.0" \
          "jinja2==3.1.2"
        
        echo "=== 📦 Packages after hardcoded installation ==="
        pip list --format=freeze
    
    - name: ✅ Strict version verification
      run: |
        echo "=== ✅ Verifying exact version matches ==="
        
        python -c "
        import pkg_resources
        import sys
        
        # 读取requirements.txt
        try:
            with open('requirements.txt', 'r') as f:
                requirements = [line.strip() for line in f.readlines() 
                              if line.strip() and not line.strip().startswith('#')]
        except FileNotFoundError:
            print('❌ requirements.txt not found!')
            sys.exit(1)
        
        print(f'📋 Found {len(requirements)} requirements to verify')
        
        # 获取当前安装的包
        installed = {pkg.project_name.lower(): pkg.version for pkg in pkg_resources.working_set}
        
        errors = []
        success = []
        
        for req in requirements:
            if '==' in req:
                pkg_name, expected_version = req.split('==', 1)
                pkg_name = pkg_name.strip().lower()
                expected_version = expected_version.strip()
                
                if pkg_name in installed:
                    actual_version = installed[pkg_name]
                    if actual_version == expected_version:
                        success.append(f'✅ {pkg_name}: {actual_version}')
                    else:
                        errors.append(f'❌ {pkg_name}: got {actual_version}, expected {expected_version}')
                else:
                    errors.append(f'❌ {pkg_name}: not installed')
        
        print('\n=== ✅ SUCCESSFUL MATCHES ===')
        for s in success:
            print(s)
        
        if errors:
            print(f'\n=== ❌ MISMATCHES ({len(errors)}) ===')
            for error in errors:
                print(error)
            
            print('\n=== 📦 ALL INSTALLED PACKAGES ===')
            for name, version in sorted(installed.items()):
                print(f'{name}=={version}')
            
            print(f'\n🚨 FAILURE: {len(errors)} version mismatches found!')
            sys.exit(1)
        else:
            print(f'\n🎉 SUCCESS: All {len(success)} packages match exactly!')
        "
    
    - name: Cache papers directory only
      uses: actions/cache@v4
      with:
        path: papers
        key: ${{ runner.os }}-papers-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-papers-
    
    - name: Run paper analysis
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
        EMAIL_TO: ${{ secrets.EMAIL_TO }}
      run: |
        cd src
        python main.py
    
    - name: Commit and push changes
      run: |
        git config --global user.name 'TomasAndersonFang'
        git config --global user.email 'fangsen1996@gmail.com'
        git add .
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update paper analysis for $(date +'%Y-%m-%d')"
          git push
        fi
