name: Daily Paper Analysis
on:
  schedule:
    - cron: '0 0 * * *'  # æ¯å¤© UTC æ—¶é—´ 00:00 è¿è¡Œ
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘

jobs:
  analyze-papers:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        # å®Œå…¨ç¦ç”¨ç¼“å­˜
    
    - name: ğŸ” Deep diagnosis of requirements files
      run: |
        echo "=== ğŸ” COMPREHENSIVE FILE SEARCH ==="
        echo "Current working directory: $(pwd)"
        echo "All requirements-related files:"
        find . -name "*requirements*" -o -name "*require*" -o -name "*.txt" | head -20
        echo ""
        
        echo "=== ğŸ“ Directory structure ==="
        ls -la
        echo ""
        
        echo "=== ğŸ” ALL requirements*.txt files ==="
        find . -name "requirements*.txt" -type f -exec echo "ğŸ“„ Found: {}" \; -exec echo "  Full path: $(realpath {})" \; -exec echo "  Content:" \; -exec cat {} \; -exec echo "  Hash: $(md5sum {})" \; -exec echo "" \;
        
        echo "=== ğŸ“„ Current directory requirements.txt ==="
        if [ -f "./requirements.txt" ]; then
          echo "âœ… ./requirements.txt exists"
          echo "Full path: $(realpath ./requirements.txt)"
          echo "Size: $(wc -l < ./requirements.txt) lines, $(wc -c < ./requirements.txt) bytes"
          echo "Permissions: $(ls -la ./requirements.txt)"
          echo "Content (with line numbers):"
          cat -n ./requirements.txt
          echo "MD5: $(md5sum ./requirements.txt)"
          echo "SHA256: $(sha256sum ./requirements.txt)"
        else
          echo "âŒ ./requirements.txt NOT FOUND!"
        fi
        echo ""
        
        echo "=== ğŸ” Search for ANY file containing package versions ==="
        echo "Files containing 'arxiv':"
        grep -r "arxiv" . --include="*.txt" --include="*.cfg" --include="*.ini" --include="*.toml" --include="*.yml" --include="*.yaml" 2>/dev/null || echo "No files found"
        echo ""
        
        echo "=== ğŸŒ¿ Git status and recent changes ==="
        git status
        echo ""
        git log --oneline -5
        echo ""
        
        echo "=== ğŸ” Check if requirements.txt is tracked by git ==="
        git ls-files | grep requirements || echo "No requirements files tracked by git"
    
    - name: ğŸ› ï¸ Force create correct requirements.txt
      run: |
        echo "=== ğŸ› ï¸ Creating the CORRECT requirements.txt file ==="
        
        # å¤‡ä»½ç°æœ‰çš„requirements.txtï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if [ -f "./requirements.txt" ]; then
          echo "ğŸ“„ Backing up existing requirements.txt"
          cp ./requirements.txt ./requirements.txt.backup.$(date +%s)
          echo "Current content of existing file:"
          cat ./requirements.txt
        fi
        
        # å¼ºåˆ¶åˆ›å»ºæ­£ç¡®çš„requirements.txtæ–‡ä»¶
        cat > ./requirements.txt << 'EOF'
arxiv==2.2.0
openai==0.28.0
requests==2.32.4
python-dotenv==1.0.0
jinja2==3.1.2
EOF
        
        echo "âœ… Created new requirements.txt with correct versions:"
        cat ./requirements.txt
        echo ""
        echo "File info:"
        ls -la ./requirements.txt
        echo "MD5: $(md5sum ./requirements.txt)"
        
        # éªŒè¯æ–‡ä»¶å¯è¯»æ€§
        echo "=== ğŸ” Verify file readability ==="
        python -c "
with open('requirements.txt', 'r') as f:
    content = f.read()
    print('Python can read the file:')
    print(repr(content))
    lines = content.strip().split('\n')
    print(f'Found {len(lines)} lines')
    for i, line in enumerate(lines, 1):
        print(f'Line {i}: {repr(line)}')
"
    
    - name: ğŸ§¹ Complete cache elimination and fresh installation
      run: |
        echo "=== ğŸ§¹ Completely eliminating all caches ==="
        
        # åˆ é™¤æ‰€æœ‰å¯èƒ½çš„pipç¼“å­˜ä½ç½®
        python -m pip cache purge
        rm -rf ~/.cache/pip* ~/.pip /tmp/pip* 2>/dev/null || true
        sudo rm -rf /root/.cache/pip* 2>/dev/null || true
        
        # åˆ é™¤GitHub Actionsç‰¹æœ‰çš„ç¼“å­˜
        rm -rf /opt/hostedtoolcache/Python/*/x64/lib/python*/site-packages/pip/_internal/cache 2>/dev/null || true
        rm -rf /opt/hostedtoolcache/pip_cache 2>/dev/null || true
        
        # æ¸…é™¤å¯èƒ½å½±å“ç¼“å­˜çš„ç¯å¢ƒå˜é‡
        unset PIP_CACHE_DIR PIP_FIND_LINKS PIP_EXTRA_INDEX_URL
        export PIP_NO_CACHE_DIR=1
        export PIP_DISABLE_PIP_VERSION_CHECK=1
        
        echo "=== â¬†ï¸ Upgrading pip without cache ==="
        python -m pip install --upgrade pip --no-cache-dir --force-reinstall
        
        echo "=== ğŸ—‘ï¸ Uninstalling existing packages ==="
        pip freeze | grep -v "^pip==" | grep -v "^setuptools==" | grep -v "^wheel==" > current_packages.txt || true
        if [ -s current_packages.txt ]; then
          echo "Uninstalling:"
          cat current_packages.txt
          pip uninstall -y -r current_packages.txt || true
        fi
        
        echo "=== âœ… Verification: packages after cleanup ==="
        pip list --format=freeze
        
        echo "=== ğŸ§ª Test pip's requirements parsing ==="
        pip install --dry-run --no-cache-dir -r "$REQUIREMENTS_FILE" || echo "Dry run completed"
        
        echo "=== ğŸš€ Installing with EXPLICIT file verification ==="
        
        # æ˜¾ç¤ºå°†è¦ä½¿ç”¨çš„æ–‡ä»¶
        echo "ğŸ“„ About to install from:"
        echo "File: $(realpath requirements.txt)"
        echo "Content:"
        cat requirements.txt
        echo ""
        
        # ä½¿ç”¨ç»å¯¹è·¯å¾„ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„æ–‡ä»¶
        REQUIREMENTS_FILE="$(realpath requirements.txt)"
        echo "ğŸ¯ Using absolute path: $REQUIREMENTS_FILE"
        
        # éªŒè¯pipä¼šè¯»å–ä»€ä¹ˆå†…å®¹
        echo "=== ğŸ” Pre-install verification ==="
        python -c "
import subprocess
import sys

# æ¨¡æ‹Ÿpipè¯»å–requirementsæ–‡ä»¶çš„è¿‡ç¨‹
print('Testing what pip will read:')
with open('$REQUIREMENTS_FILE', 'r') as f:
    lines = f.readlines()
    for i, line in enumerate(lines, 1):
        line = line.strip()
        if line and not line.startswith('#'):
            print(f'  Line {i}: {line}')
"
        
        # ä½¿ç”¨ç»å¯¹è·¯å¾„å®‰è£…ï¼Œå¹¶å®æ—¶æ˜¾ç¤ºè¾“å‡º
        pip install --no-cache-dir \
                   --force-reinstall \
                   --no-deps \
                   --index-url https://pypi.org/simple/ \
                   --disable-pip-version-check \
                   --verbose \
                   -r "$REQUIREMENTS_FILE"
        
        echo "=== ğŸ”„ Installing dependencies ==="
        pip install --no-cache-dir \
                   --force-reinstall \
                   --index-url https://pypi.org/simple/ \
                   --disable-pip-version-check \
                   --verbose \
                   -r "$REQUIREMENTS_FILE"
        
        echo "=== ğŸ“¦ Final package verification ==="
        pip list --format=freeze
    
    - name: ğŸ¯ Hardcoded version installation (fallback)
      if: failure()
      run: |
        echo "=== ğŸ¯ Using hardcoded versions as fallback ==="
        
        # ä½¿ç”¨æ‚¨æœŸæœ›çš„ç¡®åˆ‡ç‰ˆæœ¬
        pip install --no-cache-dir --force-reinstall \
          "arxiv==2.2.0" \
          "openai==0.28.0" \
          "requests==2.32.4" \
          "python-dotenv==1.0.0" \
          "jinja2==3.1.2"
        
        echo "=== ğŸ“¦ Packages after hardcoded installation ==="
        pip list --format=freeze
    
    - name: âœ… Strict version verification
      run: |
        echo "=== âœ… Verifying exact version matches ==="
        
        python -c "
        import pkg_resources
        import sys
        
        # è¯»å–requirements.txt
        try:
            with open('requirements.txt', 'r') as f:
                requirements = [line.strip() for line in f.readlines() 
                              if line.strip() and not line.strip().startswith('#')]
        except FileNotFoundError:
            print('âŒ requirements.txt not found!')
            sys.exit(1)
        
        print(f'ğŸ“‹ Found {len(requirements)} requirements to verify')
        
        # è·å–å½“å‰å®‰è£…çš„åŒ…
        installed = {pkg.project_name.lower(): pkg.version for pkg in pkg_resources.working_set}
        
        errors = []
        success = []
        
        for req in requirements:
            if '==' in req:
                pkg_name, expected_version = req.split('==', 1)
                pkg_name = pkg_name.strip().lower()
                expected_version = expected_version.strip()
                
                if pkg_name in installed:
                    actual_version = installed[pkg_name]
                    if actual_version == expected_version:
                        success.append(f'âœ… {pkg_name}: {actual_version}')
                    else:
                        errors.append(f'âŒ {pkg_name}: got {actual_version}, expected {expected_version}')
                else:
                    errors.append(f'âŒ {pkg_name}: not installed')
        
        print('\n=== âœ… SUCCESSFUL MATCHES ===')
        for s in success:
            print(s)
        
        if errors:
            print(f'\n=== âŒ MISMATCHES ({len(errors)}) ===')
            for error in errors:
                print(error)
            
            print('\n=== ğŸ“¦ ALL INSTALLED PACKAGES ===')
            for name, version in sorted(installed.items()):
                print(f'{name}=={version}')
            
            print(f'\nğŸš¨ FAILURE: {len(errors)} version mismatches found!')
            sys.exit(1)
        else:
            print(f'\nğŸ‰ SUCCESS: All {len(success)} packages match exactly!')
        "
    
    - name: Cache papers directory only
      uses: actions/cache@v4
      with:
        path: papers
        key: ${{ runner.os }}-papers-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-papers-
    
    - name: Run paper analysis
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
        EMAIL_TO: ${{ secrets.EMAIL_TO }}
      run: |
        cd src
        python main.py
    
    - name: Commit and push changes
      run: |
        git config --global user.name 'TomasAndersonFang'
        git config --global user.email 'fangsen1996@gmail.com'
        git add .
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update paper analysis for $(date +'%Y-%m-%d')"
          git push
        fi
